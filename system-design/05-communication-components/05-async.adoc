= ğŸ”„ Asynchronous Communication in Payment Integration
OtÃ¡vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io

== ğŸ” Sequence Diagram: Payment Webhook with Message Queue

[mermaid,payment-async-sequence,format=svg]
----
sequenceDiagram
    participant ğŸ’³ Payment Provider
    participant ğŸŒ Webhook Service
    participant ğŸ—ƒï¸ Raw DB
    participant ğŸ“¤ Message Queue
    participant ğŸ§  Payment System

    ğŸ’³ Payment Provider->>ğŸŒ Webhook Service: POST /payment/webhook (REST)
    ğŸŒ Webhook Service->>ğŸ—ƒï¸ Raw DB: Save webhook payload
    ğŸŒ Webhook Service->>ğŸ“¤ Message Queue: Publish "payment.received" event
    ğŸ“¤ Message Queue-->>ğŸ§  Payment System: Consume payment.received
    ğŸ§  Payment System->>ğŸ§  Payment System: Process business logic
----

== ğŸ§± Component Diagram: Decoupled Payment Flow

[mermaid,payment-async-components,format=svg]
----
flowchart TD
    Provider["ğŸ’³ Payment Provider"]:::ext
    Webhook["ğŸŒ Webhook Service"]
    RawDB[["ğŸ—ƒï¸ Raw Webhook DB"]]
    Queue["ğŸ“¤ Message Queue\n(Kafka, RabbitMQ, etc.)"]
    Payment["ğŸ§  Payment System"]

    Provider --> Webhook : Webhook POST
    Webhook --> RawDB : Store event
    Webhook --> Queue : Emit message
    Queue --> Payment : Async message
    Payment --> Payment : Process payment

    classDef ext fill=#fdf6e3,stroke=#333,stroke-width=2,stroke-dasharray: 5 5
----

== ğŸ¯ Why This Architecture?

* ğŸŒ The **Webhook Service** is responsible for **receiving external requests** and storing raw data safely.
* ğŸ§³ A **message is published** so the internal **Payment System** can process asynchronously.
* ğŸ§µ This decouples external events from internal systems, enabling:
- Retry logic
- Auditing of raw data
- Parallel or delayed processing

== ğŸ’¡ Notes

* The Raw DB can be a PostgreSQL or NoSQL store.
* The message format may follow a schema (e.g., Avro, JSON Schema).
* Use dead-letter queues or retry strategies for resilience.
