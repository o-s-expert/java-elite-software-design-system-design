= ğŸ”„ Asynchronous Communication in Payment Integration
OtÃ¡vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io

== Sequence Diagram: Payment Webhook with Message Queue

[source, mermaid]
----
sequenceDiagram
    participant ğŸ’³ Payment Provider
    participant ğŸŒ Webhook Service
    participant ğŸ—ƒï¸ Raw DB
    participant ğŸ“¤ Message Queue
    participant ğŸ§  Payment System

    ğŸ’³ Payment Provider->>ğŸŒ Webhook Service: POST /payment/webhook (REST)
    ğŸŒ Webhook Service->>ğŸ—ƒï¸ Raw DB: Save webhook payload
    ğŸŒ Webhook Service->>ğŸ“¤ Message Queue: Publish "payment.received" event
    ğŸ“¤ Message Queue-->>ğŸ§  Payment System: Consume payment.received
    ğŸ§  Payment System->>ğŸ§  Payment System: Process business logic
----

== Component Diagram: Decoupled Payment Flow

[source, mermaid]
----
flowchart TD
    Provider["ğŸ’³ Payment Provider"]:::ext
    Webhook["ğŸŒ Webhook Service"]
    RawDB[("ğŸ—ƒï¸ Raw Webhook DB")]
    Queue["ğŸ“¤ Message Queue (Kafka, RabbitMQ, etc.)"]
    Payment["ğŸ§  Payment System"]

    Provider --> Webhook
    Webhook --> RawDB
    Webhook --> Queue
    Queue --> Payment
----

== Why This Architecture?

* ğŸŒ The **Webhook Service** is responsible for **receiving external requests** and storing raw data safely.
* ğŸ§³ A **message is published** so the internal **Payment System** can process asynchronously.
* ğŸ§µ This decouples external events from internal systems, enabling:
- Retry logic
- Auditing of raw data
- Parallel or delayed processing

== ğŸ’¡ Notes

* The Raw DB can be a PostgreSQL or NoSQL store.
* The message format may follow a schema (e.g., Avro, JSON Schema).
* Use dead-letter queues or retry strategies for resilience.
