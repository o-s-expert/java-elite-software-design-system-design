= Internal Integration ‚Äì Java Backend ‚Üî Stock Service
Ot√°vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io

== Sequence Diagram: Inventory Check via gRPC

[source, mermaid]
----
sequenceDiagram
    participant üßë Client
    participant üü¶ Java Backend
    participant üì¶ Stock Service
    participant üóÉÔ∏è Inventory DB

    üßë Client->>üü¶ Java Backend: Place Order (productId)
    üü¶ Java Backend->>üì¶ Stock Service: gRPC checkAvailability(productId)
    üì¶ Stock Service->>üóÉÔ∏è Inventory DB: SELECT quantity
    üóÉÔ∏è Inventory DB-->>üì¶ Stock Service: Available/Not Available
    üì¶ Stock Service-->>üü¶ Java Backend: Availability status
    üü¶ Java Backend-->>üßë Client: Order accepted or rejected
----

== Component Diagram: Internal gRPC Call

[source, mermaid]
----
flowchart TD
    Client["üßë Client\n(Web/Mobile App)"]:::sub
    Backend["üü¶ Java Backend"]
    Stock["üì¶ Stock Service (gRPC)"]
    DB[["üóÉÔ∏è Inventory Database"]]

    Client --> Backend
    Backend --> Stock : gRPC checkAvailability
    Stock --> DB

    classDef sub shape=subroutine
----

== üõ†Ô∏è Notes

* This use case is ideal for gRPC:
- Internal microservices
- Known contract (`.proto`)
- Low-latency checks
* Service-to-service security can be added with mTLS or service mesh

