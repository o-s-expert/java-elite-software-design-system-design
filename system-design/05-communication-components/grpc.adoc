= Internal Integration ‚Äì Java Backend ‚Üî Stock Service
Ot√°vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io


==  C4Context ‚Äì REST Payment Integration

[source, mermaid]
----
C4Context
title System Context ‚Äì gRPC Stock Check

Enterprise_Boundary(company, "Company System") {
    Person(customer, "üßë Customer", "Places orders via Web/Mobile App")

    System(backend, "üü¶ Java Backend", "Handles order placement and inventory requests")

    System_Boundary(internal, "Internal Services") {
        System(stock_service, "üì¶ Stock Service", "Checks item availability and updates stock")
        SystemDb(stock_db, "üóÉÔ∏è Inventory DB", "Stores product stock levels")
    }
}

Rel(customer, backend, "Places order", "HTTPS")
Rel(backend, stock_service, "gRPC checkAvailability", "gRPC/protobuf")
Rel(stock_service, stock_db, "Reads/Writes stock data", "JDBC/SQL")

UpdateLayoutConfig($c4ShapeInRow="2", $c4BoundaryInRow="1")
----

==  C4Container ‚Äì REST Payment Integration

[source, mermaid]
----
C4Container
title Container Diagram ‚Äì Java Backend ‚Üî Stock Service (gRPC)

Person(customer, "üßë Customer", "End user placing orders via web or mobile")

Container_Boundary(app, "Company Backend System") {
    Container(client_app, "Client App", "React / Web", "Interface for placing orders")
    Container(backend, "Java Backend", "Java + Spring Boot", "Handles business logic and gRPC calls")
    Container(stock_service, "Stock Service", "Java + gRPC", "Processes stock availability checks and updates")
    ContainerDb(inventory_db, "Inventory DB", "PostgreSQL", "Stores product stock levels")
}

Rel(customer, client_app, "Uses", "HTTPS")
Rel(client_app, backend, "Places order", "HTTPS/JSON")
Rel(backend, stock_service, "checkAvailability()", "gRPC")
Rel(stock_service, inventory_db, "Reads/Writes", "JDBC/SQL")

UpdateLayoutConfig($c4ShapeInRow="3", $c4BoundaryInRow="1")
----

== Sequence Diagram: Inventory Check via gRPC

[source, mermaid]
----
sequenceDiagram
    participant üßë Client
    participant üü¶ Java Backend
    participant üì¶ Stock Service
    participant üóÉÔ∏è Inventory DB

    üßë Client->>üü¶ Java Backend: Place Order (productId)
    üü¶ Java Backend->>üì¶ Stock Service: gRPC checkAvailability(productId)
    üì¶ Stock Service->>üóÉÔ∏è Inventory DB: SELECT quantity
    üóÉÔ∏è Inventory DB-->>üì¶ Stock Service: Available/Not Available
    üì¶ Stock Service-->>üü¶ Java Backend: Availability status
    üü¶ Java Backend-->>üßë Client: Order accepted or rejected
----

== Component Diagram: Internal gRPC Call

[source, mermaid]
----
flowchart TD
    Client["üßë Client\n(Web/Mobile App)"]:::sub
    Backend["üü¶ Java Backend"]
    Stock["üì¶ Stock Service (gRPC)"]
    DB[["üóÉÔ∏è Inventory Database"]]

    Client --> Backend
    Backend --> Stock : gRPC checkAvailability
    Stock --> DB

    classDef sub shape=subroutine
----

== üõ†Ô∏è Notes

* This use case is ideal for gRPC:
- Internal microservices
- Known contract (`.proto`)
- Low-latency checks
* Service-to-service security can be added with mTLS or service mesh

