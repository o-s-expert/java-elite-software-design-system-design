= ‚öôÔ∏è gRPC Service-to-Service Communication
Ot√°vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io

== Sequence Diagram: gRPC Internal Request Flow

[source, mermaid]
----
sequenceDiagram
    participant üßë Client
    participant üü¶ Gateway
    participant üì¶ UserService
    participant üß† AuthService
    participant üóÉÔ∏è Database

    üßë Client->>üü¶ Gateway: Request user info
    üü¶ Gateway->>üß† AuthService: gRPC Validate(token)
    üß† AuthService-->>üü¶ Gateway: Token OK
    üü¶ Gateway->>üì¶ UserService: gRPC GetUser(id)
    üì¶ UserService->>üóÉÔ∏è Database: SELECT user by ID
    üóÉÔ∏è Database-->>üì¶ UserService: User data
    üì¶ UserService-->>üü¶ Gateway: User data
    üü¶ Gateway-->>üßë Client: JSON response
----

üß≠ gRPC is used **internally** (Auth ‚Üî UserService), allowing:
- Strongly typed contracts
- Low latency
- Language-agnostic communication

JSON is still used at the edge to talk to external clients.

== Component Diagram: gRPC Inside a Java System

[source, mermaid]
----
flowchart TD
    Client["üßë Client\n(Web or Mobile App)"]:::sub
    Gateway["üü¶ API Gateway\n(RestController)"]
    Auth["üß† Auth Service\n(gRPC Java Server)"]
    User["üì¶ User Service\n(gRPC Java Server)"]
    DB[["üóÉÔ∏è PostgreSQL"]]

    Client --> Gateway
    Gateway --> Auth : gRPC ValidateToken
    Gateway --> User : gRPC GetUser
    User --> DB

    classDef sub shape=subroutine
----

== üõ†Ô∏è Java + gRPC Development Notes

* Use `protobuf` to define `.proto` interfaces:
[source,proto]
----
service AuthService {
  rpc ValidateToken (TokenRequest) returns (TokenResponse);
}
----
* Java implementation via `grpc-java` plugin:
- Server: extend generated base class
- Client: use generated stubs
* Supports:
- Unary, Server/Client streaming, Bi-directional streaming
* Integration with Spring Boot via `grpc-spring-boot-starter`

