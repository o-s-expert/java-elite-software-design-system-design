= üí≥ REST Payment Integration ‚Äì Practical Example
Ot√°vio Santana
:toc: left
:icons: font
:sectnums:
:kroki-server-url: https://kroki.io

== üîÑ Sequence Diagram: REST-Based Payment (with Eventual HTTP Request)

[source, mermaid]
----
sequenceDiagram
    participant üßë Client
    participant üü¶ Backend System
    participant üí≥ Payment Provider
    participant üì¶ Order Service
    participant üóÉÔ∏è Database

    üßë Client->>üü¶ Backend System: Checkout Request
    üü¶ Backend System->>üí≥ Payment Provider: POST /payments
    üí≥ Payment Provider-->>üü¶ Backend System: Payment Confirmation (Immediate)
    üü¶ Backend System->>üì¶ Order Service: Mark order as paid
    üì¶ Order Service->>üóÉÔ∏è Database: Update order status
    note over üí≥ Payment Provider,üü¶ Backend System: Later...\nEventual HTTP webhook with status
    üí≥ Payment Provider-->>üü¶ Backend System: POST /payment/webhook
----

üß≠ *Important*:
This is not truly asynchronous ‚Äî the webhook is an **eventual HTTP call** made later by the provider.
It's handled in Java using `@PostMapping` + `@RequestBody` in a Spring `@RestController`.


[source, mermaid]
----
flowchart TD
    Client((("üßë Client\n(Web/Mobile App)"))):::sub
    Backend["üü¶ Backend System"]
    Payment{{"üí≥ Payment Provider(e.g., Stripe API)"}}
    Order["üì¶ Order Service"]
    DB[("üóÉÔ∏è PostgreSQL Database")]


    Client --> Backend
    Backend --> Payment
    Backend --> Order
    Order --> DB
    Payment --> Backend
----

== üõ†Ô∏è Java Stack Notes

* REST client: `WebClient` or `RestTemplate`
* Webhook receiver:
[source,java]
----
@PostMapping("/payment/webhook")
public ResponseEntity<Void> handle(@RequestBody PaymentStatus payload) {
    // process status
    return ResponseEntity.ok().build();
}
----
* JSON handled via Jackson (`@JsonProperty`, etc.)
* Optional: `Resilience4j` for retries, timeouts, and circuit breakers
